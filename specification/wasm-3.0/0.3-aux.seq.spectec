;;
;; General Functions on Sequences
;;

;; Type casting

def $opt_(syntax X, X*) : X?  hint(show %2)
def $opt_(syntax X, eps) = eps
def $opt_(syntax X, w) = w


;; Concatenation

def $concat_(syntax X, (X*)*) : X*  hint(show (++) %2) hint(inverse $invconcat_)
def $concat_(syntax X, eps) = eps
def $concat_(syntax X, (w*) (w'*)*) = w* ++ $concat_(X, (w'*)*)

def $concatn_(syntax X, (X*)*, nat) : X*  hint(show (++) %2) hint(inverse $invconcatn_)
def $concatn_(syntax X, eps, n) = eps
def $concatn_(syntax X, (w^n) (w'^n)*, n) = w^n $concatn_(X, (w'^n)*, n)

def $invconcat_(syntax X, X*) : (X*)*        hint(builtin $inverse_of_concat)
def $invconcatn_(syntax X, nat, X*) : (X*)*  hint(builtin $inverse_of_concatn)


;; List manipulation


;; This version might be easier to define in theorem provers (eyeball close)
def $rev_(syntax X, X*) : X*
def $rev_(syntax X, []) = []
def $rev_(syntax X, w_0 w*) = $rev_(X, w*) w_0

;; This version is more succinct in SpecTec.
def $rev'_(syntax X, X*) : X*
def $rev'_(syntax X, w^N) = (w^N[N-1-i])^(i < N)

def $filter_(syntax X, def $p(X) : bool, X*) : X*
def $filter_(syntax X, $p, []) = []
def $filter_(syntax X, $p, w_0 w*) = w_0 $filter_(X, $p, w*)  -- if $p(w_0)
def $filter_(syntax X, $p, w_0 w*) = $filter_(X, $p, w*)  -- otherwise


def $take_(syntax X, nat, X*) : X*
def $take_(syntax X, 0, w*) = []
def $take_(syntax X, n, []) = []
def $take_(syntax X, n, w w'*) = w $take_(X, $(n-1), w'*)  -- if n > 0

def $take'_(syntax X, nat, X*) : X*
def $take'_(syntax X, n, w^n') = w^n'    -- if n' < n
def $take'_(syntax X, n, w^n w'*) = w^n

def $takeWhile_(syntax X, def $p(X) : bool, X*) : X*
def $takeWhile_(syntax X, $p, []) = []
def $takeWhile_(syntax X, $p, w_0 w*) = w_0 $takeWhile_(X, $p, w*)  -- if $p(w_0)
def $takeWhile_(syntax X, $p, w_0 w*) = []                          -- otherwise


def $drop_(syntax X, nat, X*) : X*
def $drop_(syntax X, 0, w*) = w*
def $drop_(syntax X, n, []) = []
def $drop_(syntax X, n, w w'*) = $drop_(X, $(n-1), w'*)  -- if n > 0

;; Doesn't work with the interpreter backend
def $drop'_(syntax X, nat, X*) : X*
def $drop'_(syntax X, n, w^n') = []      -- if n' < n
def $drop'_(syntax X, n, w^n w'*) = w'*



;; Set functions

def $disjoint_(syntax X, X*) : bool  hint(show %2 $disjoint) hint(macro none)
def $disjoint_(syntax X, eps) = true
def $disjoint_(syntax X, w w'*) = ~(w <- w'*) /\ $disjoint_(X, w'*)

def $setminus_(syntax X, X*, X*) : X*  hint(show %2\%3)
def $setminus1_(syntax X, X, X*) : X*

def $setminus_(syntax X, eps, w*) = eps
def $setminus_(syntax X, w_1 w'*, w*) = $setminus1_(X, w_1, w*) ++ $setminus_(X, w'*, w*)
def $setminus1_(syntax X, w, eps) = w
def $setminus1_(syntax X, w, w_1 w'*) = eps                     -- if w = w_1
def $setminus1_(syntax X, w, w_1 w'*) = $setminus1_(X, w, w'*)  -- otherwise

;; [{1, 2}, {a, b, c}] -> {[1, a], [1, b], [1, c], [2, a], [2, b], [2, c]}
def $setproduct_(syntax X, (X*)*) : (X*)*  hint(show %latex("{\\Large\\times}") %2)
def $setproduct1_(syntax X, X*, (X*)*) : (X*)*
def $setproduct2_(syntax X, X, (X*)*) : (X*)*

def $setproduct_(syntax X, eps) = (eps)
def $setproduct_(syntax X, (w_1*) (w*)*) = $setproduct1_(X, w_1*, $setproduct_(X, (w*)*))
def $setproduct1_(syntax X, eps, (w*)*) = eps
def $setproduct1_(syntax X, w_1 w'*, (w*)*) = $setproduct2_(X, w_1, (w*)*) ++ $setproduct1_(X, w'*, (w*)*)
def $setproduct2_(syntax X, w_1, eps) = eps
def $setproduct2_(syntax X, w_1, (w'*) (w*)*) = (w_1 w'*) ++ $setproduct2_(X, w_1, (w*)*)
